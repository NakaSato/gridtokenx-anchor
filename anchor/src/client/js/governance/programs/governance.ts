/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedEmergencyPauseInstruction,
  type ParsedEmergencyUnpauseInstruction,
  type ParsedGetGovernanceStatsInstruction,
  type ParsedInitializePoaInstruction,
  type ParsedIssueErcInstruction,
  type ParsedSetMaintenanceModeInstruction,
  type ParsedUpdateAuthorityInfoInstruction,
  type ParsedUpdateErcLimitsInstruction,
  type ParsedUpdateGovernanceConfigInstruction,
  type ParsedValidateErcForTradingInstruction,
} from '../instructions';

export const GOVERNANCE_PROGRAM_ADDRESS =
  '4DY97YYBt4bxvG7xaSmWy3MhYhmA6HoMajBHVqhySvXe' as Address<'4DY97YYBt4bxvG7xaSmWy3MhYhmA6HoMajBHVqhySvXe'>;

export enum GovernanceAccount {
  ErcCertificate,
  MeterAccount,
  PoAConfig,
}

export function identifyGovernanceAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): GovernanceAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([83, 161, 134, 16, 240, 92, 186, 157])
      ),
      0
    )
  ) {
    return GovernanceAccount.ErcCertificate;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([87, 111, 139, 87, 181, 20, 104, 255])
      ),
      0
    )
  ) {
    return GovernanceAccount.MeterAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([119, 6, 28, 138, 199, 43, 5, 184])
      ),
      0
    )
  ) {
    return GovernanceAccount.PoAConfig;
  }
  throw new Error(
    'The provided account could not be identified as a governance account.'
  );
}

export enum GovernanceInstruction {
  EmergencyPause,
  EmergencyUnpause,
  GetGovernanceStats,
  InitializePoa,
  IssueErc,
  SetMaintenanceMode,
  UpdateAuthorityInfo,
  UpdateErcLimits,
  UpdateGovernanceConfig,
  ValidateErcForTrading,
}

export function identifyGovernanceInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): GovernanceInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([21, 143, 27, 142, 200, 181, 210, 255])
      ),
      0
    )
  ) {
    return GovernanceInstruction.EmergencyPause;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([83, 249, 195, 57, 206, 189, 31, 85])
      ),
      0
    )
  ) {
    return GovernanceInstruction.EmergencyUnpause;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([67, 29, 241, 120, 15, 8, 9, 16])
      ),
      0
    )
  ) {
    return GovernanceInstruction.GetGovernanceStats;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([98, 199, 82, 10, 244, 161, 157, 46])
      ),
      0
    )
  ) {
    return GovernanceInstruction.InitializePoa;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([174, 248, 149, 107, 155, 4, 196, 8])
      ),
      0
    )
  ) {
    return GovernanceInstruction.IssueErc;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([87, 100, 0, 28, 116, 52, 46, 40])
      ),
      0
    )
  ) {
    return GovernanceInstruction.SetMaintenanceMode;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([199, 12, 195, 232, 185, 99, 112, 145])
      ),
      0
    )
  ) {
    return GovernanceInstruction.UpdateAuthorityInfo;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([235, 208, 197, 149, 62, 109, 254, 110])
      ),
      0
    )
  ) {
    return GovernanceInstruction.UpdateErcLimits;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([140, 45, 181, 17, 77, 67, 157, 248])
      ),
      0
    )
  ) {
    return GovernanceInstruction.UpdateGovernanceConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([9, 215, 176, 63, 247, 150, 72, 139])
      ),
      0
    )
  ) {
    return GovernanceInstruction.ValidateErcForTrading;
  }
  throw new Error(
    'The provided instruction could not be identified as a governance instruction.'
  );
}

export type ParsedGovernanceInstruction<
  TProgram extends string = '4DY97YYBt4bxvG7xaSmWy3MhYhmA6HoMajBHVqhySvXe',
> =
  | ({
      instructionType: GovernanceInstruction.EmergencyPause;
    } & ParsedEmergencyPauseInstruction<TProgram>)
  | ({
      instructionType: GovernanceInstruction.EmergencyUnpause;
    } & ParsedEmergencyUnpauseInstruction<TProgram>)
  | ({
      instructionType: GovernanceInstruction.GetGovernanceStats;
    } & ParsedGetGovernanceStatsInstruction<TProgram>)
  | ({
      instructionType: GovernanceInstruction.InitializePoa;
    } & ParsedInitializePoaInstruction<TProgram>)
  | ({
      instructionType: GovernanceInstruction.IssueErc;
    } & ParsedIssueErcInstruction<TProgram>)
  | ({
      instructionType: GovernanceInstruction.SetMaintenanceMode;
    } & ParsedSetMaintenanceModeInstruction<TProgram>)
  | ({
      instructionType: GovernanceInstruction.UpdateAuthorityInfo;
    } & ParsedUpdateAuthorityInfoInstruction<TProgram>)
  | ({
      instructionType: GovernanceInstruction.UpdateErcLimits;
    } & ParsedUpdateErcLimitsInstruction<TProgram>)
  | ({
      instructionType: GovernanceInstruction.UpdateGovernanceConfig;
    } & ParsedUpdateGovernanceConfigInstruction<TProgram>)
  | ({
      instructionType: GovernanceInstruction.ValidateErcForTrading;
    } & ParsedValidateErcForTradingInstruction<TProgram>);
