/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedCancelOrderInstruction,
  type ParsedCreateBuyOrderInstruction,
  type ParsedCreateSellOrderInstruction,
  type ParsedInitializeInstruction,
  type ParsedInitializeMarketInstruction,
  type ParsedMatchOrdersInstruction,
  type ParsedUpdateMarketParamsInstruction,
} from '../instructions';

export const TRADING_PROGRAM_ADDRESS =
  'GZnqNTJsre6qB4pWCQRE9FiJU2GUeBtBDPp6s7zosctk' as Address<'GZnqNTJsre6qB4pWCQRE9FiJU2GUeBtBDPp6s7zosctk'>;

export enum TradingAccount {
  ErcCertificate,
  Market,
  Order,
  TradeRecord,
}

export function identifyTradingAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): TradingAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([83, 161, 134, 16, 240, 92, 186, 157])
      ),
      0
    )
  ) {
    return TradingAccount.ErcCertificate;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([219, 190, 213, 55, 0, 227, 198, 154])
      ),
      0
    )
  ) {
    return TradingAccount.Market;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([134, 173, 223, 185, 77, 86, 28, 51])
      ),
      0
    )
  ) {
    return TradingAccount.Order;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([150, 248, 182, 169, 229, 100, 24, 37])
      ),
      0
    )
  ) {
    return TradingAccount.TradeRecord;
  }
  throw new Error(
    'The provided account could not be identified as a trading account.'
  );
}

export enum TradingInstruction {
  CancelOrder,
  CreateBuyOrder,
  CreateSellOrder,
  Initialize,
  InitializeMarket,
  MatchOrders,
  UpdateMarketParams,
}

export function identifyTradingInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): TradingInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([95, 129, 237, 240, 8, 49, 223, 132])
      ),
      0
    )
  ) {
    return TradingInstruction.CancelOrder;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([182, 87, 0, 160, 192, 66, 151, 130])
      ),
      0
    )
  ) {
    return TradingInstruction.CreateBuyOrder;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([53, 52, 255, 44, 191, 74, 171, 225])
      ),
      0
    )
  ) {
    return TradingInstruction.CreateSellOrder;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])
      ),
      0
    )
  ) {
    return TradingInstruction.Initialize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([35, 35, 189, 193, 155, 48, 170, 203])
      ),
      0
    )
  ) {
    return TradingInstruction.InitializeMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([17, 1, 201, 93, 7, 51, 251, 134])
      ),
      0
    )
  ) {
    return TradingInstruction.MatchOrders;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([70, 117, 202, 191, 205, 174, 92, 82])
      ),
      0
    )
  ) {
    return TradingInstruction.UpdateMarketParams;
  }
  throw new Error(
    'The provided instruction could not be identified as a trading instruction.'
  );
}

export type ParsedTradingInstruction<
  TProgram extends string = 'GZnqNTJsre6qB4pWCQRE9FiJU2GUeBtBDPp6s7zosctk',
> =
  | ({
      instructionType: TradingInstruction.CancelOrder;
    } & ParsedCancelOrderInstruction<TProgram>)
  | ({
      instructionType: TradingInstruction.CreateBuyOrder;
    } & ParsedCreateBuyOrderInstruction<TProgram>)
  | ({
      instructionType: TradingInstruction.CreateSellOrder;
    } & ParsedCreateSellOrderInstruction<TProgram>)
  | ({
      instructionType: TradingInstruction.Initialize;
    } & ParsedInitializeInstruction<TProgram>)
  | ({
      instructionType: TradingInstruction.InitializeMarket;
    } & ParsedInitializeMarketInstruction<TProgram>)
  | ({
      instructionType: TradingInstruction.MatchOrders;
    } & ParsedMatchOrdersInstruction<TProgram>)
  | ({
      instructionType: TradingInstruction.UpdateMarketParams;
    } & ParsedUpdateMarketParamsInstruction<TProgram>);
