\documentclass[conference,10pt]{IEEEtran}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{setspace}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,calc}

% Code Listing Setup
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{Rust}{
    keywords={true,false,let,mut,if,else,while,for,loop,match,return,break,continue,pub,fn,struct,enum,impl,trait,type,mod,use,crate,extern,const,static,unsafe,async,await,move,ref,box,self,Self,super,where,in,as,dyn,abstract,become,do,final,macro,override,priv,try,typeof,unsized,virtual,yield},
    keywordstyle=\color{magenta},
    ndkeywords={u8,u16,u32,u64,u128,i8,i16,i32,i64,i128,f32,f64,bool,char,str,String,Vec,Option,Result,Box,Rc,Arc,Cell,RefCell,HashMap,BTreeMap,HashSet,BTreeSet,LinkedList,VecDeque,BinaryHeap,Duration,Instant,SystemTime,Path,PathBuf,File,OpenOptions,Read,Write,BufRead,BufReader,BufWriter,Stdin,Stdout,Stderr,Command,Child,ExitStatus,OsString,OsStr,CString,CStr,Mutex,RwLock,Condvar,Barrier,Once,Thread,Builder,JoinHandle,LocalKey,AtomicBool,AtomicIsize,AtomicUsize,AtomicPtr},
    ndkeywordstyle=\color{codepurple},
    sensitive=true,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{codegreen},
    stringstyle=\color{codepurple},
    morestring=[b]",
}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=mystyle}

% For Thai language support with XeLaTeX
\usepackage{fontspec}
\usepackage{polyglossia}
\setdefaultlanguage{thai}
\setotherlanguage{english}

% Use TH Sarabun New font (installed in user fonts)
\defaultfontfeatures{Ligatures=TeX}
\setmainfont{THSarabunNew}[
    Path = /Users/chanthawat/Library/Fonts/,
    Extension = .ttf,
    UprightFont = THSarabunNew,
    BoldFont = THSarabunNew Bold,
    ItalicFont = THSarabunNew Italic,
    BoldItalicFont = THSarabunNew BoldItalic,
    Scale = 1.3,
    LetterSpace = 0.5
]

% Use same font for sans-serif and monospace to avoid polyglossia warnings
\setsansfont{THSarabunNew}[
    Path = /Users/chanthawat/Library/Fonts/,
    Extension = .ttf,
    Scale = 1.3
]
\setmonofont{THSarabunNew}[
    Path = /Users/chanthawat/Library/Fonts/,
    Extension = .ttf,
    Scale = 1.3
]

% Adjust line spacing for Thai text readability  
\linespread{1.15}

% Thai line breaking configuration
\XeTeXlinebreaklocale "th"
\XeTeXlinebreakskip = 0pt plus 3pt minus 1pt
\XeTeXlinebreakpenalty = 0

% Better paragraph spacing
\setlength{\parskip}{0.5ex plus 0.2ex minus 0.1ex}

% Fix underfull/overfull box warnings
\tolerance=1000
\emergencystretch=3em
\hfuzz=0.5pt
\vfuzz=0.5pt

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\begin{document}
\sloppy

\title{การพัฒนาระบบจำลองการซื้อขายพลังงานแสงอาทิตย์แบบ Peer-to-Peer โดยใช้ Solana Smart Contract\\
\large (Anchor Framework ในสภาพแวดล้อมแบบ Permissioned)}

\author{\IEEEauthorblockN{นายจันทร์ธวัฒ กิริยาดี}
\IEEEauthorblockA{\textit{คณะวิศวกรรมศาสตร์} \\
\textit{สาขาวิศวกรรมคอมพิวเตอร์และปัญญาประดิษฐ์}\\
\textit{มหาวิทยาลัยหอการค้าไทย}\\
กรุงเทพมหานคร ประเทศไทย \\
2410717302003@live4.utcc.ac.th}
}

\maketitle

\begin{abstract}
บทความนี้นำเสนอการประเมินประสิทธิภาพอย่างครอบคลุมของ GridTokenX ซึ่งเป็นแพลตฟอร์มการซื้อขายพลังงานแบบ Peer-to-Peer (P2P) แบบกระจายศูนย์ที่สร้างบน Solana cluster แบบส่วนตัว เราใช้วิธีการ BLOCKBENCH (SIGMOD 2017) สำหรับการวิเคราะห์แบบชั้นต่อชั้นอย่างเป็นระบบ ร่วมกับการดัดแปลง TPC-C benchmark สำหรับการประเมินภาระงานจริง ผลการทดลองยืนยันประสิทธิภาพของระบบด้วยค่า \textbf{2,111 tpmC} (transactions per minute Type C) และความหน่วงเฉลี่ยเพียง 116ms ซึ่งเหมาะสมสำหรับการใช้งานจริง การวิเคราะห์ด้วย BLOCKBENCH แสดงให้เห็นว่าสถาปัตยกรรมแบบขนานของ Solana ช่วยขจัดคอขวดในการประมวลผล โดยทำได้ 231 TPS ในชั้น Execution นอกจากนี้ งานวิจัยยังนำเสนอแนวคิด "Trust Premium" (58.28 เท่า) เพื่อเปรียบเทียบต้นทุนประสิทธิภาพกับระบบรวมศูนย์ (PostgreSQL) นอกจากนี้ยังอธิบายการปรับปรุงระดับต่ำโดยเฉพาะ รวมถึงการคำนวณแบบจำนวนเต็มเท่านั้นและการอัปเดตสถานะแบบ lazy ที่ช่วยเพิ่มปริมาณงานขณะรักษาค่าคงที่ทางคณิตศาสตร์อย่างเข้มงวดสำหรับการอนุรักษ์พลังงาน
\end{abstract}

\begin{IEEEkeywords}
บล็อกเชน, การซื้อขายพลังงาน, Solana, TPC-C, BLOCKBENCH, YCSB, การทดสอบประสิทธิภาพ, Smart Contracts
\end{IEEEkeywords}

\section{บทนำ}
การกระจายศูนย์ของระบบพลังงานผ่านทรัพยากรพลังงานแบบกระจาย (Distributed Energy Resources หรือ DERs) ต้องการโครงสร้างพื้นฐานการซื้อขายที่แข็งแกร่งสามารถจัดการธุรกรรมขนาดเล็กความถี่สูงได้ \cite{b2} รูปแบบสาธารณูปโภคแบบรวมศูนย์แบบดั้งเดิมประสบปัญหาความเสี่ยงจุดล้มเหลวเดียวและขาดความโปร่งใสในการกำหนดราคา เทคโนโลยีบล็อกเชนเสนอทางออกแต่มักถูกวิพากษ์วิจารณ์เรื่องข้อจำกัดด้านความสามารถในการขยายตัว \cite{b4}

งานวิจัยนี้ประเมิน GridTokenX ซึ่งใช้ประโยชน์จาก Sealevel parallel runtime ของ Solana \cite{b3} เพื่อเอาชนะคอขวดเหล่านี้ แตกต่างจากบล็อกเชนยุคก่อนหน้า Solana นำเสนอ deterministic finality ในโหมด Permissioned และความสามารถในการประมวลผลธุรกรรมที่ไม่ทับซ้อนกันแบบขนาน ซึ่งเหมาะสมอย่างยิ่งสำหรับการซื้อขายพลังงานที่มีปริมาณธุรกรรมสูง วัตถุประสงค์ของการศึกษานี้คือ:
\begin{enumerate}
    \item เพื่อศึกษาและนำเสนอสถาปัตยกรรมของระบบจำลองการซื้อขายพลังงาน P2P โดยใช้ Solana (Anchor) ในสภาพแวดล้อม Permissioned (PoA)
    \item เพื่อพัฒนาและพิสูจน์แนวคิด (Proof-of-Concept) ของระบบต้นแบบที่สามารถจำลองการแลกเปลี่ยน GRID Token โดยใช้ AMI Simulator
    \item เพื่อประเมินและวิเคราะห์ประสิทธิภาพโดยใช้การวิเคราะห์ชั้น BLOCKBENCH และชุด TPC benchmark
\end{enumerate}

\section{งานวิจัยที่เกี่ยวข้อง: วิธีการ BLOCKBENCH}
BLOCKBENCH \cite{b4} ให้กรอบการทำงานอย่างเป็นระบบสำหรับการประเมินประสิทธิภาพบล็อกเชนส่วนตัวผ่านสี่ชั้นสถาปัตยกรรม:

\begin{enumerate}
    \item \textbf{Consensus Layer}: วัดค่าใช้จ่าย consensus บริสุทธิ์ผ่านการทำงาน DoNothing
    \item \textbf{Execution Layer}: ประเมินการคำนวณ smart contract ผ่านภาระงานที่ใช้ CPU มาก
    \item \textbf{Data Model Layer}: ทดสอบประสิทธิภาพการอ่าน/เขียนสถานะโดยใช้ IOHeavy benchmarks
    \item \textbf{Application Layer}: การจำลองภาระงานจริงโดยใช้ YCSB และ Smallbank
\end{enumerate}

เราขยายวิธีการ BLOCKBENCH ไปยัง Solana/Anchor ด้วยการใช้งาน Rust ดั้งเดิมของแต่ละหมวดหมู่ benchmark

งานวิจัยก่อนหน้านี้ได้สำรวจการใช้บล็อกเชนสำหรับการซื้อขายพลังงาน เช่น Brooklyn Microgrid \cite{b2} และโครงการที่ใช้ Ethereum หรือ Hyperledger Fabric \cite{b5, b6} อย่างไรก็ตาม ระบบเหล่านี้มักเผชิญกับข้อจำกัดด้านความสามารถในการขยายตัว (Scalability) และความหน่วงที่สูงเมื่อปริมาณธุรกรรมเพิ่มขึ้น งานวิจัยนี้นำเสนอทางเลือกใหม่โดยใช้สถาปัตยกรรมประสิทธิภาพสูงของ Solana

\section{สถาปัตยกรรมระบบ}
แพลตฟอร์มถูกใช้งานเป็นชุดของห้า Anchor smart contracts ที่เชื่อมต่อกันบน Solana โดยใช้ Program Derived Addresses (PDAs) เพื่อจัดการสิทธิ์การเข้าถึงข้อมูลอย่างปลอดภัยและเป็นระบบ:
1. \textbf{Registry}: จัดการตัวตนผู้ใช้และทรัพย์สินมิเตอร์
2. \textbf{Oracle}: ตรวจสอบข้อมูลเซ็นเซอร์นอกเครือข่าย
3. \textbf{Energy Token}: โทเค็นที่เป็นไปตาม SPL แทน 1 kWh
4. \textbf{Trading}: order book และเครื่องมือการชำระราคา
5. \textbf{Governance}: การกำหนดค่าและพารามิเตอร์ DAO

\section{วิธีการ}

\subsection{การแมป TPC-C}
เราแมปธุรกรรม TPC-C มาตรฐาน \cite{b1} กับการซื้อขายพลังงานที่เทียบเท่าเพื่อสร้างโปรไฟล์ภาระงานที่สมจริง ค่า tpmC (transactions per minute Type C) คำนวณจากจำนวนธุรกรรม New-Order ที่สำเร็จต่อนาที:
\begin{equation}
tpmC = \frac{Total\_New\_Orders}{Duration\_Minutes}
\end{equation}

\begin{table}[t!]
\caption{การแมป TPC-C กับการซื้อขายพลังงาน}
\begin{center}
\begin{tabular}{lcl}
\toprule
\textbf{ธุรกรรม TPC-C} & \textbf{สัดส่วน} & \textbf{ฟังก์ชัน GridTokenX} \\
\midrule
New Order & 45\% & \texttt{create\_sell\_order} / \texttt{create\_buy\_order} \\
Payment & 43\% & \texttt{transfer\_tokens} (การชำระราคา) \\
Order Status & 4\% & \texttt{get\_order\_status} (RPC Read) \\
Delivery & 4\% & \texttt{match\_orders} (การทำงานแบบ Batch) \\
Stock Level & 4\% & \texttt{get\_balance} (การตรวจสอบพลังงาน) \\
\bottomrule
\end{tabular}
\label{tab:tpcc-mapping}
\end{center}
\end{table}

\subsection{แบบจำลองทางคณิตศาสตร์}

\subsubsection{กลไกการกำหนดราคา VWAP}
เพื่อให้มั่นใจในมูลค่าตลาดที่เป็นธรรม แพลตฟอร์มใช้อัลกอริทึมการค้นหาราคาถัวเฉลี่ยถ่วงน้ำหนักปริมาณ (VWAP) ราคา clearing $P_{clearing}$ คำนวณแบบไดนามิก:

\begin{equation}
P_{base} = \frac{P_{bid} + P_{ask}}{2}
\end{equation}

\begin{equation}
P_{clearing} = P_{base} + \left( P_{base} \times \min\left(\frac{V_{trade}}{V_{total}}, 1.0\right) \times \delta_{max} \right)
\end{equation}

โดยที่ $V_{trade}$ คือปริมาณการจับคู่ปัจจุบัน, $V_{total}$ คือปริมาณในอดีต และ $\delta_{max}$ คือปัจจัยความยืดหยุ่นราคาสูงสุด (10\%)

\subsubsection{ค่าคงที่การอนุรักษ์โทเค็น}
ระบบบังคับใช้การอนุรักษ์พลังงานอย่างเข้มงวด โทเค็น ($\Delta Supply_{GRID}$) สามารถสร้างได้เฉพาะเมื่อพลังงานที่ผลิตทางกายภาพถูกชำระทางคณิตศาสตร์:

\begin{equation}
\Delta Supply_{GRID} = \max(0, (E_{produced} - E_{consumed}) - E_{settled})
\end{equation}

\subsubsection{การปรับปรุงระบบ}
เพื่อเพิ่มปริมาณงานสูงสุดภายในขีดจำกัด Compute Unit (CU) ของ Solana เราใช้การปรับปรุงสำคัญสามประการ:

\textbf{A. การคำนวณแบบจำนวนเต็มเท่านั้น:} 
การดำเนินการจุดทศนิยม (\texttt{f64}) มีค่าใช้จ่ายคำนวณสูงและไม่แนะนำในโปรแกรม Solana เราแทนที่การคำนวณ VWAP ด้วยคณิตศาสตร์จุดคงที่จำนวนเต็ม:
\begin{equation}
W = \min\left(\frac{V \times 1000}{V_{total}}, 1000\right)
\end{equation}
การลดนี้ประหยัดได้ประมาณ 10,000 CUs ต่อการทำธุรกรรม

\textbf{B. การอัปเดตสถานะแบบ Lazy:}
แทนที่จะ serialize อาร์เรย์ประวัติราคาทั้งหมด (100+ รายการ) ทุกธุรกรรม การอัปเดตจะถูก "commit แบบ lazy" เฉพาะเมื่อการเบี่ยงเบนราคาเกิน 5\% หรือทุก 60 วินาที ซึ่งลดค่าใช้จ่าย serialization ลง 90\%

\textbf{C. การจับคู่คำสั่งแบบ Batch:}
คำสั่ง \texttt{match\_orders} ถูก refactor เพื่อจัดการการทำงานแบบ batch ทำให้สามารถชำระ limit orders หลายรายการที่ไม่ทับซ้อนกันในธุรกรรมอะตอมิกเดียว ปรับปรุงอัตรา "fills per second" อย่างมีนัยสำคัญ

\section{การตั้งค่าการทดลอง}
Benchmarks ดำเนินการบน Solana localnet cluster ประสิทธิภาพสูง (Single Node Setup) เพื่อวัดประสิทธิภาพสูงสุดของ Validator node เดียวโดยไม่มีความหน่วงเครือข่ายภายนอก
\begin{itemize}
    \item \textbf{ฮาร์ดแวร์}: Apple M-Series (8-core), 16GB RAM
    \item \textbf{Cluster}: Solana Test Validator v1.18
    \item \textbf{Client}: ตัวสร้างภาระงาน Rust แบบ multi-threaded
    \item \textbf{Baseline}: PostgreSQL 14 รันบนฮาร์ดแวร์เดียวกันสำหรับการเปรียบเทียบ Trust Premium
\end{itemize}

\section{การประเมินประสิทธิภาพ}

\subsection{การวิเคราะห์ชั้น BLOCKBENCH}
ตามวิธีการ BLOCKBENCH เราประเมินแต่ละชั้นสถาปัตยกรรมอย่างอิสระ:

\begin{table}[t!]
\caption{ผลลัพธ์ BLOCKBENCH Micro-benchmark}
\begin{center}
\begin{tabular}{|l|l|r|r|}
\hline
\textbf{ชั้น} & \textbf{Benchmark} & \textbf{TPS} & \textbf{ความหน่วง} \\
\hline
Consensus & DoNothing & 225 & 2.5ms \\
Execution & CPUHeavy-Sort & 231 & 2.5ms \\
Data Model & IOHeavy-Write & 192 & 3.0ms \\
Data Model & IOHeavy-Mixed & 192 & 3.0ms \\
\hline
\end{tabular}
\label{tab:blockbench}
\end{center}
\end{table}

ตัวเลข TPS เหล่านี้ถูกจำกัดโดยประสิทธิภาพของ Client ในการเซ็นและส่งธุรกรรมในสภาพแวดล้อมการทดสอบ ไม่ใช่ขีดจำกัดสูงสุดของ Solana runtime อย่างไรก็ตาม มันแสดงให้เห็นถึงความสม่ำเสมอของการประมวลผล

DoNothing benchmark วัดค่าใช้จ่าย consensus บริสุทธิ์ (225 TPS) ในขณะที่การดำเนินการ CPUHeavy sorting ทำได้ 231 TPS แสดงการทำงาน smart contract ที่มีประสิทธิภาพ IOHeavy benchmarks ที่ 192 TPS แสดงค่าใช้จ่ายของ state serialization

\subsection{ผลลัพธ์ YCSB Workload}
เราใช้สามโปรไฟล์ YCSB workload เพื่อประเมินประสิทธิภาพ application-layer:

\begin{table}[t!]
\caption{ประสิทธิภาพ YCSB Workload}
\begin{center}
\begin{tabular}{|l|l|r|r|}
\hline
\textbf{Workload} & \textbf{โปรไฟล์} & \textbf{ops/s} & \textbf{ความหน่วง} \\
\hline
YCSB-A & 50\% อ่าน, 50\% อัปเดต & 290 & 2.7ms \\
YCSB-B & 95\% อ่าน, 5\% อัปเดต & 442 & 1.8ms \\
YCSB-C & 100\% อ่าน & 391 & 2.1ms \\
\hline
\end{tabular}
\label{tab:ycsb}
\end{center}
\end{table}

Smallbank OLTP benchmark ทำได้ \textbf{1,714 TPS} โดยมีความหน่วงเฉลี่ย 5.83ms แสดงประสิทธิภาพที่แข็งแกร่งสำหรับภาระงานทางการเงิน

\subsection{การวิเคราะห์ปริมาณงาน TPC-C}
การใช้งาน TPC-C benchmark ของเราทำได้ปริมาณงาน \textbf{2,111 tpmC} (76.85 TPS) ในโหมดจำลอง ปริมาณงานนี้เกิดจาก \textit{Sealevel} parallel runtime โดยตรง ซึ่งอนุญาตให้ธุรกรรมที่ไม่ทับซ้อนกัน (เช่น การซื้อขายระหว่างคู่ผู้ใช้ที่ต่างกัน) ทำงานพร้อมกัน ในบล็อกเชนแบบ EVM ดั้งเดิม ธุรกรรมเหล่านี้จะถูก serialize ทำให้เกิดคอขวด

ในการรัน benchmark ของเรา มีธุรกรรมทั้งหมด 4,621 รายการถูกประมวลผลโดย 4,611 รายการสำเร็จ (\textbf{อัตราสำเร็จ 99.78\%}) ส่วนผสมธุรกรรมเป็นไปตามข้อกำหนด TPC-C:
\begin{itemize}
    \item New-Order: 2,074 ธุรกรรม (44.9\%) -- สำเร็จ 99.71\%
    \item Payment: 2,004 ธุรกรรม (43.4\%) -- สำเร็จ 99.80\%
    \item Order-Status: 197 ธุรกรรม (4.3\%) -- สำเร็จ 100\%
    \item Delivery: 175 ธุรกรรม (3.8\%) -- สำเร็จ 100\%
    \item Stock-Level: 171 ธุรกรรม (3.7\%) -- สำเร็จ 100\%
\end{itemize}

สำหรับตลาด P2P ระดับภูมิภาคที่มี 10,000 ครัวเรือน สมมติว่าสมาร์ทมิเตอร์แต่ละตัวส่งค่าทุก 15 นาที ปริมาณงานที่ต้องการประมาณ 11 TPS 76.85 TPS ที่สังเกตได้ให้ \textbf{ส่วนเผื่อความปลอดภัย 7 เท่า} พิสูจน์ว่าสถาปัตยกรรมสามารถจัดการการติดตั้งระดับละแวกบ้านได้โดยไม่มีความแออัด

\subsection{ผลลัพธ์ TPC-E และ TPC-H}
เราขยายการประเมินเพื่อรวม TPC-E (ภาระงานนายหน้า) และ TPC-H (การสนับสนุนการตัดสินใจ) benchmarks:

\begin{table}[t!]
\caption{ผลลัพธ์ TPC-E/TPC-H Benchmark}
\begin{center}
\begin{tabular}{|l|r|r|r|}
\hline
\textbf{Benchmark} & \textbf{เมตริกหลัก} & \textbf{ความหน่วงเฉลี่ย} & \textbf{p99} \\
\hline
TPC-E & 306 tpsE & 7.89 ms & 17 ms \\
TPC-H & 250,486 QphH & 71.0 ms & 147 ms \\
\hline
\end{tabular}
\label{tab:tpce-tpch}
\end{center}
\end{table}

TPC-E benchmark ทำได้ \textbf{306 tpsE} (trades per second) แสดงประสิทธิภาพที่แข็งแกร่งสำหรับภาระงานแบบนายหน้าที่มีการจับคู่คำสั่งซับซ้อน TPC-H analytical queries ทำได้ \textbf{250,486 QphH} (queries per hour) ยืนยันความสามารถของแพลตฟอร์มสำหรับฟังก์ชันการรายงานและการตรวจสอบ

\subsection{การวิเคราะห์ความหน่วง}
ความหน่วงธุรกรรมแตกต่างอย่างมากจาก "เวลายืนยัน" ในสภาพแวดล้อม PoA แบบ permissioned นี้
\begin{enumerate}
    \item \textbf{ความหน่วงเฉลี่ย (116.56ms)}: แทนเวลาเฉลี่ยสำหรับ leader node ในการประมวลผลคำสั่งและอัปเดตสถานะในหน่วยความจำ
    \item \textbf{ความหน่วง p50 (112.57ms)}: เวลาประมวลผลธุรกรรมมัธยฐาน
    \item \textbf{ความหน่วง p95 (180.04ms)}: เปอร์เซ็นไทล์ที่ 95 ภายใต้โหลดปกติ
    \item \textbf{ความหน่วง p99 (215.54ms)}: แทนเวลาประมวลผลกรณีเลวร้ายที่สุดภายใต้โหลดหนัก
\end{enumerate}

โหมดจำลองรวม "Think Time" ตามมาตรฐาน TPC-C เพื่อจำลองพฤติกรรมผู้ใช้จริง ในสภาพแวดล้อม PoA การผลิตที่มี validators ที่ปรับปรุงแล้ว ความหน่วงคาดว่าจะต่ำกว่าอย่างมีนัยสำคัญ ไม่เหมือนกับ mainnets สาธารณะที่ finality อาจใช้เวลาหลายวินาที ธรรมชาติ permissioned ของ GridTokenX cluster อนุญาตให้มี deterministic finality

\subsection{การวิเคราะห์ Concurrency}
ภายใต้การแข่งขันสูง (หลายคำสั่งต่อสถานะตลาดเดียวกัน) Sealevel runtime linearized ธุรกรรมที่ขัดแย้งกันอย่างมีประสิทธิภาพในขณะที่ประมวลผลคำขอที่ไม่ทับซ้อนกันแบบขนาน อัตราความขัดแย้ง MVCC (Multi-Version Concurrency Control) ที่สังเกตได้คือ \textbf{1.45\%} ส่วนใหญ่เนื่องจากธรรมชาติอะตอมิกของคำสั่ง \texttt{match\_orders} จำนวนครั้งการลองใหม่เฉลี่ยคือ 0.02 แสดงการแก้ไขความขัดแย้งที่มีประสิทธิภาพ

\subsection{การวิเคราะห์ความสามารถในการขยายตัว}
เราทำการทดสอบความสามารถในการขยายตัวในสามมิติ:

\begin{table}[t!]
\caption{ผลลัพธ์การทดสอบความสามารถในการขยายตัว}
\begin{center}
\begin{tabular}{|l|r|r|r|}
\hline
\textbf{การทดสอบ} & \textbf{TPS} & \textbf{ความหน่วง} & \textbf{ความเสถียร} \\
\hline
1 thread (baseline) & 443 & 2.26ms & 100\% \\
32 concurrent threads & 398 & 2.51ms & คงไว้ 90\% \\
60s sustained load & 416 & 2.40ms & เสถียร \\
1,000 accounts & 220 & 4.54ms & ลดลงแบบเชิงเส้น \\
\hline
\end{tabular}
\label{tab:scalability}
\end{center}
\end{table}

\subsection{การเปรียบเทียบข้ามแพลตฟอร์ม}
เราเปรียบเทียบประสิทธิภาพ GridTokenX กับผลลัพธ์ที่เผยแพร่จากแพลตฟอร์มบล็อกเชนอื่น:

\begin{table}[t!]
\caption{การเปรียบเทียบประสิทธิภาพแพลตฟอร์ม}
\begin{center}
\resizebox{\columnwidth}{!}{
\begin{tabular}{|l|l|r|r|r|}
\hline
\textbf{แพลตฟอร์ม} & \textbf{Benchmark} & \textbf{TPS} & \textbf{ความหน่วง} & \textbf{แหล่งที่มา} \\
\hline
GridTokenX & Smallbank & 1,714 & 5.8ms & การศึกษานี้ \\
GridTokenX & DoNothing & 225 & 2.5ms & การศึกษานี้ \\
GridTokenX & YCSB-B & 442 & 1.8ms & การศึกษานี้ \\
\hline
Hyperledger 2.0 & Smallbank & 400 & 150ms & BLOCKBENCH \\
Hyperledger 2.0 & DoNothing & 3,500 & 45ms & BLOCKBENCH \\
Hyperledger 2.0 & YCSB & 200 & 200ms & BLOCKBENCH \\
\hline
Ethereum & DoNothing & 15 & 13,000ms & BLOCKBENCH \\
Parity & DoNothing & 140 & 650ms & BLOCKBENCH \\
\hline
\end{tabular}
}
\label{tab:comparison}
\end{center}
\end{table}

\begin{figure}[t!]
\centering
\begin{tikzpicture}
    % Axes
    \draw[thick,->] (0,0) -- (7,0);
    \draw[thick,->] (0,0) -- (0,4.5) node[anchor=south, rotate=90] {TPS (Log Scale)};
    
    % Grid lines
    \foreach \y/\label in {1.4/10, 2.8/100, 4.2/1000}
        \draw[gray!30, dashed] (0,\y) -- (7,\y) node[anchor=east] at (0,\y) {\label};

    % Bars (Log10 values scaled: 1.2cm per decade)
    % Eth: 1.17 * 1.2 = 1.4
    % Fab: 2.60 * 1.2 = 3.12
    % Grid: 3.23 * 1.2 = 3.87
    
    \fill[gray!70] (1,0) rectangle (2,1.4);
    \node[above] at (1.5,1.4) {15};
    \node[below] at (1.5,0) {Ethereum};
    
    \fill[red!70] (3,0) rectangle (4,3.12);
    \node[above] at (3.5,3.12) {400};
    \node[below] at (3.5,0) {Hyperledger};
    
    \fill[blue!70] (5,0) rectangle (6,3.87);
    \node[above] at (5.5,3.87) {\textbf{1,714}};
    \node[below] at (5.5,0) {\textbf{GridTokenX}};
    
    % Title
    \node[anchor=south] at (3.5,4.5) {\textbf{Smallbank Throughput (TPS)}};
\end{tikzpicture}
\caption{การเปรียบเทียบปริมาณงาน (TPS) ระหว่างแพลตฟอร์ม (Log Scale)}
\label{fig:comparison}
\end{figure}

แม้ว่า Hyperledger Fabric จะทำได้ปริมาณงาน DoNothing สูงกว่า (3,500 vs 225 TPS) เนื่องจากสถาปัตยกรรม execute-order-validate GridTokenX แสดง \textbf{ประสิทธิภาพ Smallbank ดีกว่า 4.3 เท่า} (1,714 vs 400 TPS) และ \textbf{ความหน่วงต่ำกว่า 26 เท่า} (5.8ms vs 150ms) สำหรับภาระงานทางการเงิน

\subsection{"Trust Premium"}
เรานิยาม "Trust Premium" เป็นต้นทุนประสิทธิภาพที่เกิดขึ้นเพื่อให้บรรลุ distributed consensus ในเครือข่ายส่วนตัวเมื่อเทียบกับ baseline แบบรวมศูนย์ (PostgreSQL)

\begin{equation}
\begin{split}
Trust\ Premium &= \frac{Latency_{Blockchain}}{Latency_{Baseline}} \\
&= \frac{116.56ms}{2.00ms} \approx 58.28x
\end{split}
\end{equation}

แม้ว่านี่จะแทนค่าใช้จ่ายความหน่วงเมื่อเทียบกับฐานข้อมูลแบบรวมศูนย์ แต่เป็นที่ยอมรับได้สำหรับแอปพลิเคชันการซื้อขายพลังงานที่การชำระราคาโดยทั่วไปใช้เวลาหลายวันหรือหลายสัปดาห์ในระบบดั้งเดิม การแลกเปลี่ยนให้:
\begin{itemize}
    \item เส้นทางการตรวจสอบธุรกรรมที่ไม่เปลี่ยนแปลง
    \item การชำระราคา smart contract อัตโนมัติ
    \item กลไกการกำหนดราคาที่โปร่งใส
    \item การขจัดความเสี่ยงจุดล้มเหลวเดียว
\end{itemize}

\subsection{สรุปผลลัพธ์ Benchmark}
ตาราง \ref{tab:benchmark-results} สรุปเมตริกประสิทธิภาพหลักจากการประเมิน benchmark อย่างครอบคลุมของเรา

\begin{table}[t!]
\caption{สรุปผลลัพธ์ Benchmark อย่างครอบคลุม}
\begin{center}
\begin{tabular}{|l|c|}
\hline
\textbf{เมตริก} & \textbf{ค่า} \\
\hline
\multicolumn{2}{|c|}{\textit{BLOCKBENCH Micro-benchmarks}} \\
\hline
DoNothing (Consensus) & 225 TPS \\
CPUHeavy (Execution) & 231 TPS \\
IOHeavy (Data Model) & 192 TPS \\
\hline
\multicolumn{2}{|c|}{\textit{YCSB/Smallbank}} \\
\hline
YCSB-B (95\% อ่าน) & 442 ops/s \\
Smallbank OLTP & 1,714 TPS \\
\hline
\multicolumn{2}{|c|}{\textit{ชุด TPC Benchmark}} \\
\hline
TPC-C (tpmC) & 2,111 \\
TPC-E (tpsE) & 306 \\
TPC-H (QphH) & 250,486 \\
\hline
\multicolumn{2}{|c|}{\textit{เมตริกประสิทธิภาพ}} \\
\hline
อัตราสำเร็จ & 99.78\% \\
ความหน่วงเฉลี่ย & 116.56 ms \\
ความหน่วง p99 & 215.54 ms \\
อัตราความขัดแย้ง MVCC & 1.45\% \\
Trust Premium & 58.28x \\
\hline
\end{tabular}
\label{tab:benchmark-results}
\end{center}
\end{table}

\section{กรอบการประเมินข้ามแพลตฟอร์ม}
เพื่อเปรียบเทียบ GridTokenX กับแพลตฟอร์มบล็อกเชนอื่นอย่างเข้มงวด (เช่น Ethereum, Hyperledger Fabric) \cite{b4} เราเสนอ \textit{Standardized Energy Trading Workload (SETW)} นักวิจัยต้องทำตามสามขั้นตอนเพื่อทำซ้ำวิธีการนี้:

\subsection{การใช้งาน Contract ที่เทียบเท่า}
แพลตฟอร์มเป้าหมายต้องใช้งาน logic หลักที่กำหนดในตาราง \ref{tab:tpcc-mapping} โดยเฉพาะ ฟังก์ชัน ``Order Match'' ต้องเป็น atomic ให้แน่ใจว่าการทำธุรกรรมและการชำระราคาโทเค็นเกิดขึ้นในการเปลี่ยนสถานะ cryptographic เดียวกัน

\subsection{โปรไฟล์การฉีดภาระงาน}
ตัวสร้างโหลดต้องรักษาส่วนผสม TPC-C ที่เฉพาะเจาะจง:
\begin{itemize}
    \item \textbf{เขียนหนัก (88\%)}: New Orders + Payments สิ่งนี้เน้น state contention ของ consensus engine
    \item \textbf{อ่านเบา (12\%)}: Status checks สิ่งนี้ทดสอบประสิทธิภาพ RPC query
\end{itemize}

\subsection{การ Normalize เมตริก}
ผลลัพธ์ต้องรายงานใน \textbf{tpmC} (transactions per minute Type-C) สำหรับบล็อกเชนที่มี probabilistic finality (เช่น PoW) ความหน่วงต้องรวมเวลาถึง \textit{k}-block confirmation depth เพื่อเปรียบเทียบกับ deterministic leader schedule ของ Solana

\section{สรุป}
GridTokenX แสดงให้เห็นว่าเทคโนโลยีบล็อกเชนส่วนตัวเป็นไปได้สำหรับการซื้อขายพลังงาน P2P ในการติดตั้งระดับภูมิภาค ผ่านการวิเคราะห์ชั้น BLOCKBENCH อย่างครอบคลุมและการประเมิน TPC benchmark:

\begin{itemize}
    \item \textbf{Consensus Layer}: ปริมาณงาน DoNothing 225 TPS
    \item \textbf{Execution Layer}: การคำนวณ CPUHeavy 231 TPS
    \item \textbf{Data Model}: การดำเนินการสถานะ IOHeavy 192 TPS
    \item \textbf{Application Layer}: Smallbank 1,714 TPS, YCSB-B 442 ops/s
    \item \textbf{ชุด TPC}: 2,111 tpmC, 306 tpsE, 250,486 QphH
\end{itemize}

เมื่อเทียบกับ Hyperledger Fabric GridTokenX ทำได้ \textbf{ปริมาณงาน Smallbank สูงกว่า 4.3 เท่า} และ \textbf{ความหน่วงต่ำกว่า 26 เท่า} สำหรับภาระงานทางการเงิน \textbf{Trust Premium ที่ 58.28 เท่า} ที่สังเกตได้แทนต้นทุนที่ยอมรับได้สำหรับการบรรลุเส้นทางการตรวจสอบที่ไม่เปลี่ยนแปลง การชำระราคา smart contract อัตโนมัติ และกลไกการกำหนดราคาที่โปร่งใส

งานในอนาคตจะมุ่งเน้นที่: (1) การติดตั้งบน PoA validator clusters ระดับการผลิตเพื่อให้ได้ความหน่วงต่ำลง (2) การขยายไปยังการกำหนดค่า warehouse ขนาดใหญ่ (10+ warehouses) และ (3) การทดสอบนำร่องในโลกจริงด้วยการผสานรวมสมาร์ทมิเตอร์


\IEEEtriggeratref{5}
\begin{thebibliography}{00}
\bibitem{b1} Transaction Processing Performance Council (TPC), ``TPC Benchmark C Standard Specification, Revision 5.11,'' 2010.
\bibitem{b2} E. Mengelkamp, J. G{\"a}rttner, K. Rock, S. Kessler, L. Orsini, and C. Weinhardt, ``Designing microgrid energy markets: A case study: The Brooklyn Microgrid,'' \textit{Applied Energy}, vol. 210, pp. 870--880, 2018.
\bibitem{b3} A. Yakovenko, ``Solana: A new architecture for a high performance blockchain v0.8.13,'' Solana Labs Whitepaper, 2018.
\bibitem{b4} T. T. A. Dinh, J. Wang, G. Chen, R. Liu, B. C. Ooi, and K. L. Tan, ``Blockbench: A framework for analyzing private blockchains,'' in \textit{Proc. ACM SIGMOD Int. Conf. Management of Data}, pp. 1085--1100, 2017.
\bibitem{b5} M. Andoni \textit{et al.}, ``Blockchain technology in the energy sector: A systematic review of challenges and opportunities,'' \textit{Renewable and Sustainable Energy Reviews}, vol. 100, pp. 143--174, 2019.
\bibitem{b6} Z. Li, J. Kang, R. Yu, D. Ye, Q. Deng, and Y. Zhang, ``Consortium blockchain for secure energy trading in industrial internet of things,'' \textit{IEEE Trans. Industrial Informatics}, vol. 14, no. 8, pp. 3690--3700, 2018.
\bibitem{b7} J. Guerrero, A. C. Chapman, and G. Verbic, ``Decentralized P2P energy trading under network constraints in a low-voltage network,'' \textit{IEEE Trans. Smart Grid}, vol. 10, no. 5, pp. 5163--5173, 2019.
\bibitem{b8} Anchor Framework Documentation, ``Building Secure Solana Programs,'' Coral, 2023. [Online]. Available: https://anchor-lang.com
\end{thebibliography}

\end{document}
